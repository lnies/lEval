import osimport copyimport matplotlib as mplimport matplotlib.pyplot as pltimport numpy as npimport pandas as pdfrom scipy.optimize import curve_fitimport platformimport timetry:    import ROOT as root    root_available = Trueexcept:    root_available = Falseclass Jonas():    def __init__(self):        if platform.system() == 'Darwin': # MacOS            self.file_path = 'C:'        elif platform.system() == 'Windows':            self.file_path = '/'        self.header_lines = 1        self.import_data = []        self.zoomed_data = []        self.header = ['x axis / a.u.', 'y axis / a.u.']        self.columns = ['x', 'y']        self.usecols = range(len(self.columns))        self.delimiter = ';'        self.plot_type = 'scatter'        self.plot_type_options = {'line' : 'line plot (default)',                                  'bar' : 'vertical bar plot',                                  'barh' : 'horizontal bar plot',                                  'hist' : 'histogram',                                  'box' : 'boxplot',                                  'kde' : 'Kernel Density Estimation plot',                                  'density' : 'same as "kde"',                                  'area' : 'area plot',                                  'pie' : 'pie plot',                                  'scatter' : 'scatter plot',                                  'hexbin' : 'hexbin plot'}        self.fit_function_dict = {'x^2': '<A> * x^2 + <B> * x + <C>',                                'linear': '<M> * x + <N>',                                'exp': '<A> * exp( <B> * (x - <C>)) + <D>',                                'sin': '<A> * sin( <B> * x ) + <C>',                                'sqrt': '<A> * sqrt( <B> * x ) + <C>'}        self.fit_parameter_num = {'x^2': 3,                                'linear': 2,                                'exp': 4,                                'sin': 3,                                'sqrt': 3}        self.figsize = (9,6)        self.tick_fontsize = 16        self.png_on_off = True        self.x_lim = [0, 999999999]        self.x_lim_zoom = [0, 999999999]        self.y_lim = [0, 999999999]        self.y_lim_zoom = [0, 999999999]        self.fit_option = False        self.fit_flag = True        self.fit_function = ''        self.root_available = root_available        self.lim_index_list = []        self.model = 0        self.popt = []        self.perr = []        self.isotope = ''        self.fig_num = 0        self.fit_bounds = []        self.df_dict = {}    def set_font(self):        '''Set Utopia font and label font size'''        mpl.rc('font', family='serif', serif='Utopia')        mpl.rc('text', usetex=False)        mpl.rc('axes', labelsize=22)    # fontsize of the x and y labels    def load(self, new_file_path_or_df_or_list):        '''Loads columns from text (.csv, .txt, ...) or .xlsx files or a dataframe or a list and returns a dataframe'''        if type(new_file_path_or_df_or_list)==str:            self.file_path = new_file_path_or_df_or_list            if os.path.splitext(self.file_path)[-1] == '.xlsx':                self.load_xlsx()            else:                self.load_data_df()            print('\nSuccessfully loaded :: {}'.format(os.path.split(self.file_path)[-1]))            print('Location            :: {}\n'.format(os.path.split(self.file_path)[0]))        elif type(new_file_path_or_df_or_list) == pd.core.frame.DataFrame:            self.import_data = new_file_path_or_df_or_list            print('\nSuccessfully loaded :: list\n')        elif type(new_file_path_or_df_or_list) == list:            self.import_data = pd.DataFrame(new_file_path_or_df_or_list[1:], columns=new_file_path_or_df_or_list[0])            print('\nSuccessfully loaded :: DataFrame\n')        return(self.import_data)    def load_data_df(self):        '''Imports data from raw text file (.csv, .txt, ...) to dataframe'''        self.import_data = pd.read_table(filepath_or_buffer=self.file_path,                                         delimiter=self.delimiter,                                         header=range(self.header_lines)[-1],                                         # usecols=range(len(self.columns)),                                         # usecols=self.usecols,#range(len(self.columns)),                                         )        if self.header == ['x axis / a.u.', 'y axis / a.u.']:            self.header = [str(x) for x in list(self.import_data.columns)]    def load_xlsx(self):        '''Imports data from an .xlsx file as dataframe'''        self.import_data = pd.ExcelFile(self.file_path).parse(pd.ExcelFile(self.file_path).sheet_names[0])        if self.header == ['x axis / a.u.', 'y axis / a.u.']:            self.header = [str(x) for x in list(self.import_data.columns)]    def df_to_dict(self):        for i in self.header:            self.df_dict[i] = self.import_data[i].tolist()    def get_axis_ranges(self):        self.x_lim = plt.gca().get_xlim()        self.y_lim = plt.gca().get_ylim()    def plot_data(self):        '''Plot import_data'''        # plt.ion()        self.fig_num += 1        fig = plt.figure(self.fig_num, figsize=self.figsize)        ax = fig.add_subplot(111)        if len(self.columns) == 2:            self.import_data.plot(x=self.import_data.columns[self.columns.index('x')],                                  y=self.import_data.columns[self.columns.index('y')],                                  kind=self.plot_type,                                  figsize=self.figsize,                                  fontsize=self.tick_fontsize,                                  ax=ax,                                  color='g'                                  )        elif len(self.columns) == 3:            if 'yerr' in self.columns:                self.import_data.plot(x=self.import_data.columns[self.columns.index('x')],                                      y=self.import_data.columns[self.columns.index('y')],                                      yerr=self.import_data.columns[self.columns.index('yerr')],                                      kind=self.plot_type,                                      figsize=self.figsize,                                      fontsize=self.tick_fontsize,                                      ax=ax,                                      color='g'                                      )            else:                pass    # plot 2 y values per x        elif len(self.columns) == 4:            if 'yerr' in self.columns:                if 'xerr' in self.columns:                    self.import_data.plot(x=self.import_data.columns[self.columns.index('x')],                                          y=self.import_data.columns[self.columns.index('y')],                                          xerr=self.import_data.columns[self.columns.index('xerr')],                                          yerr=self.import_data.columns[self.columns.index('yerr')],                                          kind=self.plot_type,                                          figsize=self.figsize,                                          fontsize=self.tick_fontsize,                                          ax=ax                                          )            else:                pass    # plot 3 y values per x        elif len(self.columns) == 5:            pass    # don't know yet what this could be used for....        if self.isotope != '':            anchored_text = mpl.offsetbox.AnchoredText('{}'.format(self.isotope), loc=2, prop=dict(size=16), frameon=False)            # anchored_text.patch.set_boxstyle("round,pad=0.,rounding_size=0.2")            anchored_text.patch.set_alpha(0)            ax.add_artist(anchored_text)        plt.tight_layout()      # re-arrange plot -- very helpful!        self.get_axis_ranges()        os.chdir(os.path.split(self.file_path)[0])        plt.savefig('%s.pdf' % os.path.splitext(self.file_path)[0])        if self.png_on_off:            plt.savefig('%s.PNG' % os.path.splitext(self.file_path)[0])        if self.fit_option and self.fit_flag:            ax.callbacks.connect('ylim_changed', self.fit)            plt.show()        elif self.fit_option == False and self.fit_flag == False:            plt.show()        if self.fit_flag == False and self.fit_function == 'x^2':            anchored_text = mpl.offsetbox.AnchoredText('Extremum found at x = {:3.2f}'.format(-self.popt[1]/2/self.popt[0]), loc=1, prop=dict(size=16))            anchored_text.patch.set_boxstyle("round,pad=0.,rounding_size=0.2")            anchored_text.patch.set_alpha(0.8)            ax.add_artist(anchored_text)        if self.fit_flag == False and self.fit_function == 'exp':            anchored_text = mpl.offsetbox.AnchoredText(r'$T_{\frac{1}{2}}$'+'= {:3.2f}'.format(-np.log(2)/self.popt[1]), loc=1, prop=dict(size=16))            anchored_text.patch.set_boxstyle("round,pad=0.,rounding_size=0.2")            anchored_text.patch.set_alpha(0.8)            ax.add_artist(anchored_text)    def fit(self, axes):        # print 'fit within following range:\n{}\n{}'.format(self.x_lim, self.y_lim)        if root_available:            self.fit_python()        else:            self.fit_python()    def zoom_data(self):        '''Returns a reduced dataframe zoomed by x-axis'''        zoomed_tmp_x = self.import_data[self.import_data[str(self.import_data.columns[self.columns.index('x')])] > self.x_lim[0]]        zoomed_data_x = zoomed_tmp_x[zoomed_tmp_x[str(self.import_data.columns[self.columns.index('x')])] < self.x_lim[1]]        zoomed_tmp_y = zoomed_data_x[zoomed_data_x[str(self.import_data.columns[self.columns.index('y')])] > self.y_lim[0]]        self.zoomed_data = zoomed_tmp_y[zoomed_tmp_y[str(self.import_data.columns[self.columns.index('y')])] < self.y_lim[1]]        self.x_lim_zoom = self.x_lim        self.y_lim_zoom = self.y_lim    def fit_python(self):        '''Fit data with scipy optimize.'''        self.get_axis_ranges()        self.zoom_data()        if len(self.columns) == 3:            if 'yerr' in self.columns:                sigma = self.zoomed_data[str(self.import_data.columns[self.columns.index('yerr')])].tolist()        else:            sigma = [1 for i in self.zoomed_data[str(self.import_data.columns[self.columns.index('x')])].tolist()]        if self.fit_function == 'x^2':            self.popt, pcov = curve_fit(self.scipy_model_poly2,                                   xdata=self.zoomed_data[str(self.import_data.columns[self.columns.index('x')])].tolist(),                                   ydata=self.zoomed_data[str(self.import_data.columns[self.columns.index('y')])].tolist(),                                   sigma=sigma, bounds=(self.fit_bounds[0::2], self.fit_bounds[1::2]))        elif self.fit_function == 'linear':            self.popt, pcov = curve_fit(self.scipy_model_linear,                                   xdata=self.zoomed_data[str(self.import_data.columns[self.columns.index('x')])].tolist(),                                   ydata=self.zoomed_data[str(self.import_data.columns[self.columns.index('y')])].tolist(),                                   sigma=sigma, bounds=(self.fit_bounds[0::2], self.fit_bounds[1::2]))        elif self.fit_function == 'exp':            self.popt, pcov = curve_fit(self.scipy_model_exp,                                   xdata=self.zoomed_data[str(self.import_data.columns[self.columns.index('x')])].tolist(),                                   ydata=self.zoomed_data[str(self.import_data.columns[self.columns.index('y')])].tolist(),                                   sigma=sigma, bounds=(self.fit_bounds[0::2], self.fit_bounds[1::2]))        elif self.fit_function == 'sin':            self.popt, pcov = curve_fit(self.scipy_model_sin,                                   xdata=self.zoomed_data[str(self.import_data.columns[self.columns.index('x')])].tolist(),                                   ydata=self.zoomed_data[str(self.import_data.columns[self.columns.index('y')])].tolist(),                                   sigma=sigma, bounds=(self.fit_bounds[0::2], self.fit_bounds[1::2]))        elif self.fit_function == 'sqrt':            self.popt, pcov = curve_fit(self.scipy_model_sqrt,                                   xdata=self.zoomed_data[str(self.import_data.columns[self.columns.index('x')])].tolist(),                                   ydata=self.zoomed_data[str(self.import_data.columns[self.columns.index('y')])].tolist(),                                   sigma=sigma, bounds=(self.fit_bounds[0::2], self.fit_bounds[1::2]))        print 'Fit function        ::', self.fit_function_dict[self.fit_function]        print 'Fit parameter       :: ', self.popt        self.perr = np.sqrt(np.diag(pcov))      # calculate uncertainty of fit parameters        print 'Fit parameter unc.  :: ', self.perr, '\n'        self.fit_flag = False                   # forbids a second fit        self.plot_data()                        # plot again full range ...        if self.fit_function == 'x^2':            plt.plot(np.linspace(self.x_lim_zoom[0], self.x_lim_zoom[1], 1000), self.scipy_model_poly2(np.linspace(self.x_lim_zoom[0], self.x_lim_zoom[1], 1000), *self.popt), 'r-')                # ... with fit        elif self.fit_function == 'linear':            plt.plot(np.linspace(self.x_lim_zoom[0], self.x_lim_zoom[1], 1000), self.scipy_model_linear(np.linspace(self.x_lim_zoom[0], self.x_lim_zoom[1], 1000), *self.popt), 'r-')                # ... with fit        elif self.fit_function == 'exp':            plt.plot(np.linspace(self.x_lim_zoom[0], self.x_lim_zoom[1], 1000), self.scipy_model_exp(np.linspace(self.x_lim_zoom[0], self.x_lim_zoom[1], 1000), *self.popt), 'r-')                # ... with fit        elif self.fit_function == 'sin':            plt.plot(np.linspace(self.x_lim_zoom[0], self.x_lim_zoom[1], 1000), self.scipy_model_sin(np.linspace(self.x_lim_zoom[0], self.x_lim_zoom[1], 1000), *self.popt), 'r-')                # ... with fit        elif self.fit_function == 'sqrt':            plt.plot(np.linspace(self.x_lim_zoom[0], self.x_lim_zoom[1], 1000), self.scipy_model_sqrt(np.linspace(self.x_lim_zoom[0], self.x_lim_zoom[1], 1000), *self.popt), 'r-')                # ... with fit        if platform.system() == 'Darwin': # MacOS            plt.close(1)    # closes original (zoomed) figure @ a Mac        plt.savefig('%s.pdf' % os.path.splitext(self.file_path)[0])        if self.png_on_off:            plt.savefig('%s.PNG' % os.path.splitext(self.file_path)[0])        plt.show()        if platform.system() == 'Windows':            plt.close(1)    # closes original (zoomed) figure @ a Windoof    def scipy_model_exp(self, x, a, b, c, d):        return(a*np.exp(-b*(x-c))+d)    def scipy_model_poly2(self, x, a, b, c):        return(a*x**2 + b*x + c)    def scipy_model_linear(self, x, m, n):        return(m*x + n)    def scipy_model_sin(self, x, a, b, c):        return(a*np.sin(b*x) + c)    def scipy_model_sqrt(self, x, a, b, c):        return(a*np.sqrt(b*x) + c)    def plot(self, new_file_path_or_df_or_list, columns, fit_function='', isotope='', fit_bounds=[], delimiter=';', usecolumns='', header=''):        '''Main program'''        self.delimiter = delimiter        if fit_bounds != []:            self.fit_bounds = fit_bounds        else:            self.fit_bounds = [-999999999 if i%2==0 else 999999999 for i in range(self.fit_parameter_num[fit_function]*2)]        if fit_function != '':            self.fit_function = fit_function            self.fit_flag = True            self.fit_option = True        else:            self.fit_flag = False            self.fit_option = False        if header != '':            self.header = header        self.columns=columns        if usecolumns == '':            self.usecols = range(len(self.columns))        else:            self.usecols = usecolumns        if isotope != '':            self.isotope=isotope        self.set_font()        self.load(new_file_path_or_df_or_list)        self.plot_data()    def fill_tree(self):        f = ROOT.TFile.Open('{}.root'.format(self.file_name), 'recreate')        for option in self.spot_positions:            tree_name = self.file_name.split(os.path.sep)[-1]            tree = ROOT.TTree(option, tree_name)            print 'option = ', option            # tmp_data = np.zeros((3, 1), dtype=float)            tmp_data = np.empty((3,1), dtype=float)            x_list = [x[1] for x in self.spot_positions[option]]            y_list = [x[2] for x in self.spot_positions[option]]            t_list = [x[3] for x in self.spot_positions[option]]            tree.Branch('data', tmp_data, 'x/D:y/D:tof/D')            for i in range(len(x_list)):                tmp_data[0][0] = x_list[i]                # print 'tmp_data[0][0] = ', tmp_data[0][0], 'x_list[i] = ', x_list[i]                tmp_data[1][0] = y_list[i]                tmp_data[2][0] = t_list[i]                tree.Fill()            tree.Print()            tree.Write()        f.Close()if __name__ == '__main__':    jonas = Jonas()    df = jonas.load('/Volumes/Python-DAQ/129mCd_002_p2_spot_positions.csv')    print df    # import root_pandas as RP    # RP.to_root(df, 'df.root', key='dftree')    jonas.plot('/Users/jonaskarthein/cernbox/Python/Code/129mCd_002_p2_spot_positions.csv', ['x', 'y'], fit_function='x^2', isotope='98Mo', delimiter=';', usecolumns=[1,2], header=['bla / $\mu$s', 'bla'])    # print jonas.load('E:\\Jonas\\test\\UTmagPhase_85Rb.xlsx')['unc.'].tolist()    # def fit_root(self, 'list_x', list_y, yerr_list='yerr'):    #     '''Function takes 1D list with unbinned data and returns a list with gaussian fit parameters: x, x_unc., sigma, sigma_unc.'''    #     import_list_x = [float(x) for x in list_x]    #     x_lims = [min(import_list_x), max(import_list_x)]    #     import_list_y = [float(y) for y in list_y]    #     y_lims = [min(import_list_y), max(import_list_y)]    #     if yerr_list:    #         import_list_yerr = [float(yerr) for yerr in yerr_list]    #         yerr_lims = [min(import_list_yerr), max(import_list_yerr)]    #     # f = root.TFile( 'test.root', 'recreate' )    #     tree = root.TTree( 'tree', 'tree' )    #     x = array('d', [ 0. ])    #     tree.Branch('x', x, 'x/D')    #     y = array('d', [ 0. ])    #     tree.Branch('y', y, 'y/D')    #     if yerr_list:    #         yerr = array('d', [ 0. ])    #         tree.Branch('yerr', yerr, 'yerr/D')    #     for i in range(len(import_list)):    #         x[0] = import_list_x[i]    #         y[0] = import_list_y[i]    #         if yerr_list:    #             yerr[0] = import_list_yerr[i]    #         tree.Fill()    #     x = root.RooRealVar('x', 'x', x_lims[0], x_lims[1])#, 'us')    #     y = root.RooRealVar('y', 'y', y_lims[0], y_lims[1])#, 'us')    #     if yerr_list:    #         yerr = root.RooRealVar('x', 'x', yerr_lims[0], y_lims[1])#, 'us')    #     # set vector properties    #     x = root.RooRealVar('x', 'x', 0, self.x_lim[0], self.x_lim[1])    #     y = root.RooRealVar('y', 'y', 0, self.y_lim[0], self.y_lim[1])    #     if yerr_list:    #         yerr = root.RooRealVar('yerr', 'yerr', 0., 0., 3000000.0)   # reduce list so that it fits to x and y length?    #     # set dataset    #     ds = root.RooDataSet('x-y', 'x-y-data', tree, root.RooArgSet(x, y))    #     # set fitting model    #     model = 'here'    #     result = model.fitTo(ds, root.RooFit.Range('range')) # , root.RooFit.NumCPU(4))    #     # fit results    #     x_pos = meant.getValV()    #     x_pos_err = meant.getError()    #     x_sigma = sigmax.getValV()    #     x_sigma_err = sigmax.getError()    #     return([x_pos, x_pos_err, x_sigma, x_sigma_err])    # def root_model_gauss(self):    #     meanx = root.RooRealVar('meanx', 'meanx', mean_x, mean_x-50.0, mean_x+50.0)    #     sigmax = root.RooRealVar('sigmax', 'sigmax', 50.0, 10.0, 100.0)    #     meany = root.RooRealVar('meany', 'meany', mean_y, mean_y-50.0, mean_y+50.0)    #     sigmay = root.RooRealVar('sigmay', 'sigmay', 50.0, 10.0, 100.0)    #     gaussx = root.RooGaussian('gaussx', 'Gaussian distribution', x, meanx, sigmax)    #     gaussy = root.RooGaussian('gaussy', 'Gaussian distribution', y, meany, sigmay)    #     gaussxy = root.RooProdPdf('gxy', 'gx*gy', root.RooArgList(gaussx,gaussy))    #     x.setRange('range', mean_x-10, mean_x+10)    # def root_model_gauss(self):    #     meanx = root.RooRealVar('meanx', 'meanx', mean_x, mean_x-50.0, mean_x+50.0)    #     sigmax = root.RooRealVar('sigmax', 'sigmax', 50.0, 10.0, 100.0)    #     meany = root.RooRealVar('meany', 'meany', mean_y, mean_y-50.0, mean_y+50.0)    #     sigmay = root.RooRealVar('sigmay', 'sigmay', 50.0, 10.0, 100.0)    #     gaussx = root.RooGaussian('gaussx', 'Gaussian distribution', x, meanx, sigmax)    #     gaussy = root.RooGaussian('gaussy', 'Gaussian distribution', y, meany, sigmay)    #     gaussxy = root.RooProdPdf('gxy', 'gx*gy', root.RooArgList(gaussx,gaussy))    #     x.setRange('range', mean_x-10, mean_x+10)