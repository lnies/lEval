# BIN Modules

## Processing

### Import files from any MR-ToF MS data format source

```
# Initialize data processor (example for MCS6Lst)
proc = MCS6Lst()
# Process list of data files
file_list = [path_to_file1, path_to_file2, ] # etc.
df = proc.process(file_list, to_csv=True) # returns dataframe with all processed .lst files. if to_csv==True, writes .csv file for each input file
# Sum all input files
df = proc.add_all(to_csv='file_name.csv') # returns 1D dataframe with the sum of all input files and a rolling sweep number. to_csv takes a file name to write summed file to a .csv file
```
Pars contains measurement parameters from .887 header file, data contains 2D array with the data, df contains dataframes saved under filename as key name

## Utilities

### Peaks

The peaks class reads in a dataframe generated by the processor classes. Using the scipy peak finder, the class creates a 1D histogram of the data and highlights the peaks that were found. The class can be used to draw the 1D histgram, but also a 2D histogram where the y axis corresponds to the sweep number and the x axis to the time-of-flight axis. Projections of the count rate vs sweep number and time-of-flight, as well as the count rate multiplicity are plotted as well.
 ```
# Before finding peaks, apply count rate cuts
z_cut = 99 # z_cut = number_of_max_ions
df = df[df.sweep.isin(df.sweep.value_counts()[df.sweep.value_counts() <= z_cut].index)]
# Initialize class by supplying the dataframe
peaks=Peaks(df)
# Find peaks 
bins = 20 # number of bins to be rebinned. the tof data is usually prebinned with 0.8ns bins. 20 is recommended
peaks.find_peaks(bins=bins, 
        # peak_threshold=0.1, # scipy peak finder parameter
        peak_min_distance=1000/bins, # scipy peak finder parameter
        peak_min_height= 0.2 * bins, # scipy peak finder parameter
        peak_width_inbins=20/bins, # scipy peak finder parameter
        peak_prominence=50/bins, # scipy peak finder parameter
        # peak_wlen=201, # scipy peak finder parameter
)
# Plot 1D histogram
peaks.plot()
# Plot 2D histogram
peaks.plot2d()
```
The plot parameters are documented withing the functions. 
Additionally, a time-of-flight calibration can be loaded to draw expected time-of-flight values for arbitrary masses. This calibration in the form of the ISOLTRAP tof calibration excel sheets. The excel sheet is cloaded into an instance of the MRToFUtils class (see below). Isobars, clusters, and individual isotopes or isomers can be added to be plotted in the 1D histogram.
```
# initialize an instance of the mr tof utility class 
calc = MRToFUtils(path_to_ame) # path_to_ame is path to ame file (included in this repository) 
calc.load_tof_calib(path_to_excel_sheet) # path_to_excel_sheet is path to tof calibration sheet
# load mr tof utilities into peak class
peaks.load_utils(calc)
# add lines for A=105 isobars at 2500 revs
peaks.add_isobars(A=105,nrevs=2500)
# add specific isotopes, molecules, and isomers at 2500 revs
peaks.add_isobars(iso_list=['86Sr19F', '105In', '105Cd', '105Ag', '105In-m'], nrevs=2500)
# add atomic clusters
peaks.add_clusters(isotope='12C', nrange=range(0,10,1), nrevs=0) # recommended only for spectra without trapping in the mr tof ms
# Plot 1D histogram again, now with lines for the masses
peaks.plot()
# Will also be added to the x-projection of the 2D plot
peaks.plot2d()
```
In case the tof calibration is not accurate and a peak in the tof spectrum is known, the calibration can be recalibrated using the know species.
```
known_mass = calc.get_value('105Cd', value='mass', state='gs') # fetch mass of 105Cd from the AME inside the mrtof utils instance 'calc'
calc.recalibrate_tof(new_m1=known_mass, new_tof1, nrevs=2500, nrevs=2500)
# reload calibration
peaks.load_utils(calc)
# plot recalibrated spectrum
peaks.plot()
```
## Fit

The fit module has several different fit functions that can be used on the 1D histograms. First apply count rate cuts on dataframe df:
```
# Count rate cuts
z_cut = 99
data_df = data_df_uncut[data_df_uncut.sweep.isin(data_df_uncut.sweep.value_counts()[data_df_uncut.sweep.value_counts() <= z_cut].index)]
```
Now find peaks in the 1D histogram:
```
##
bins=20
peaks=Peaks(data_df_uncut)
peaks.find_peaks(bins=bins,
        # peak_threshold=0.1,
        peak_min_distance=1000/bins,
        peak_min_height= 0.2 * bins,
        peak_width_inbins=20/bins,
        peak_prominence=50/bins,
        # peak_wlen=201,
)
# peaks.plot()
```
At least one peak needs to be found. Now the fit can be initialized:
```
# initialize class
fit = hyperEmg(df, peaks=peaks)
# convert dataframe 
fit.lst2roothist(df)
```
Depending on the fit function, a number of fit parameters have now to be contraint in the form of start value, lower limit, upper limit. In the following example, two peaks are being parameterized, sharing the same shape parameters of a hyperEMG fit function with one negative component and two positive components:
```
limits = {
	'mu0':[peak0, peak0-60, peak0+60], # location of first peak
	'mu1':[peak1, peak1-60, peak1+60], # location of second peak
	
	'sigma':[40, 5, 80], # sigma of Gaussian component to fit function

	'ntau0':[45 , 5, 100], # shape parameter of negative component
	'ptau0':[50 , 5, 250], # shape parameter of first positive component
	'ptau1':[50 ,25 , 10000], # shape parameter of second positive component

	'contrib0':[0.5, 0.05, 0.99], # Contribution of negative component to total fit function 
	'contrib1':[0.5, 0.05, 0.99], # Contribution of first positive component to total fit function
	
	'ratio0':[0.5, 0.05, 0.99], # Abundance ratio between peak0 and peak1
}
``` 
Now the fit can be excecuted:
```
# call fit using the limits that were defined. dimensions is [1,2] for one negative and two positive components. 
# the number of peaks n_comps is two. the fit range is given by xmin and xmax
# two shape parameters for peak0 and peak1 are fitted simultaneously with simultaneous = True (recommended)
result = fit.call_pdf(xmin, xmax, dimensions = [1,2], n_comps = 2, 
					simultaneous = True, bins = 20, limits=limits)
# plot and save fit. see plot() function for more options.
fit.plot(bins=20, file_out = 'output.pdf', style = 'hist')
# Save fit parameters 
fit.save_fit('output.txt')
